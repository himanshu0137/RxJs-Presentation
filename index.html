<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="css/reset.css">
	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<!-- Slide 1-->
			<section>
				<h1>Introduction To ReactiveX</h1>
				<small>Concepts and application of RX.js</small>
			</section>
			<!-- Slide 2-->
			<section>
				<h1>Prerequisites</h1>
				<ol>
					<li>Javascript</li>
					<li>Promises and their understanding.</li>
				</ol>
			</section>
			<!-- Slide 3-->
			<section>
				<h1>
					What is RxJs ?
				</h1>
				<p class="fragment">RxJS is a library for composing asynchronous and event-based programs by using
					observable sequences.</p>
				<p class="fragment">In other words it is an implementation of Reactive Programming Paradigm in
					Javascript.</p>
				<div class="fragment">
					<p>For Your Information, This concept is also implemented in other languages as well</p>
					<ol>
						<li>Python - RxPy</li>
						<li>C# - RX.Net</li>
						<li>Java - RXJava</li>
						<li>and many more</li>
					</ol>
				</div>
			</section>
			<!-- Slide 4-->
			<section>
				<h1>Installation</h1>
				<div class="fragment">
					<h6>Install through NPM</h6>
					<pre><code class="hljs">npm install rxjs</code></pre>
				</div>
				<div class="fragment">
					<h6>Usage</h6>
					<pre><code class="hljs">import * as rxjs from 'rxjs';</code></pre>
					<pre><code class="hljs">import { of } from 'rxjs';</code></pre>
					<pre><code class="hljs">import { map } from 'rxjs/operators';</code></pre>
				</div>
			</section>
			<!-- Slide 5-->
			<section>
				<h4>Essential Concepts</h4>
				<ol>
					<li>
						<strong>Observable</strong>: represents the idea of an invokable collection of future values
						or events.
					</li>
					<li>
						<strong>Observer</strong>: is a collection of callbacks that knows how to listen to values
						delivered by the Observable.
					</li>
					<li>
						<strong>Subscription</strong>: represents the execution of an Observable, is primarily useful
						for cancelling the execution.
					</li>
					<li>
						<strong>Operators</strong>: are pure functions that enable a functional programming style of
						dealing with collections with operations like map, filter, concat, flatMap, etc.
					</li>
					<li>
						<strong>Subject</strong>: is the equivalent to an EventEmitter, and the only way of
						multicasting a value or event to multiple Observers.
					</li>
				</ol>
			</section>
			<!-- Slide 6-->
			<section>
				<h1>Observable</h1>
				<p class="fragment">An observable represents a stream, or source of data that can arrive over time. You
					can create an observable from nearly anything.</p>
				<p class="fragment">Observables are lazy Push collections of multiple values.</p>
				<div class="fragment">
					<p>Comparison between different concepts</p>
					<table>
						<tr>
							<th>Notification Type/Return Values</th>
							<th>Single</th>
							<th>Multiple</th>
						</tr>
						<tr>
							<td>Pull</td>
							<td>Function</td>
							<td>Iterator</td>
						</tr>
						<tr>
							<td>Push</td>
							<td>Promise</td>
							<td>Observables</td>
						</tr>
					</table>
				</div>
			</section>
			<!-- Slide 7-->
			<section>
				<h1>Usage</h1>
				<pre><code class="hljs">var observable = Rx.Observable.create(function (observer) {
	observer.next(1);
	observer.next(2);
	observer.next(3);
	setTimeout(() => {
		observer.next(4);
		observer.complete();
	}, 1000);
});
					  
console.log('just before subscribe');
observable.subscribe({
	next: x => console.log('got value ' + x),
	error: err => console.error('something wrong occurred: ' + err),
	complete: () => console.log('done'),
});
console.log('just after subscribe');
					  </code></pre>
			</section>
			<!-- Slide 8-->
			<section>
				<h1>Observable vs Promise</h1>
				<table>
					<tr>
						<th>Promises</th>
						<th>Observable</th>
					</tr>
					<tr>
						<td>Helps you run functions asynchronously, and use their return values (or exceptions) but only
							once when executed.</td>
						<td>Helps you run functions asynchronously, and use their return values in a continuous
							sequence(multiple times) when executed.</td>
					</tr>
					<tr>
						<td>Not Lazy ie they are executed as soon they are defined</td>
						<td>By default, it is Lazy as it emits values when time progresses.</td>
					</tr>
					<tr>
						<td>Not cancellable. The two possible decisions are Reject or Resolve</td>
						<td>Has a lot of operator which simplifies coding effort.</td>
					</tr>
					<tr>
						<td>Provided natively.</td>
						<td>Have to add external library</td>
					</tr>
				</table>
			</section>
			<!-- Slide 9-->
			<section>
				<h3>Core Observable concerns:</h3>
				<ul>
					<li>Creating Observables</li>
					<li>Subscribing to Observables</li>
					<li>Executing the Observable</li>
					<li>Disposing Observables</li>
				</ul>
			</section>
			<!-- Slide 10-->
			<section>
				<h3>Creating Observables</h3>
				<pre><code class="hljs">
import { Observable } from 'rxjs';
const observable = new Observable(function subscribe(subscriber) {
	const id = setInterval(() => {
		subscriber.next('hi')
	}, 1000);
});
				</code></pre>
				<blockquote>Observables can be created with new Observable. Most commonly, observables are created using
					creation functions, like of, from, interval, etc.</blockquote>
			</section>
			<!-- Slide 11-->
			<section>
				<h3>Subscribing to Observables</h3>
				<pre><code class="hljs">
observable.subscribe(x => console.log(x));
</code></pre>
				<blockquote>Subscribing to an Observable is like calling a function, providing callbacks where the data
					will be delivered to.</blockquote>
				<aside class="notes">A subscribe call is simply a way to start an "Observable execution" and deliver
					values or events to an Observer of that execution.</aside>
			</section>
			<!-- Slide 12-->
			<section>
				<h3>Executing Observables</h3>
				There are three types of values an Observable Execution can deliver:
				<ul>
					<li><strong>Next</strong> callback: sends a value such as a Number, a String, an Object, etc.</li>
					<li><strong>Error</strong> callback: sends a JavaScript Error or exception.</li>
					<li><strong>Complete</strong> callback: does not send a value.</li>
				</ul>
				<pre><code class="hljs">
observable.subscribe(
	next: (any) => void, 
	error: (any) => void, 
	complete: () => void
);
</code></pre>
				<blockquote>In an Observable Execution, zero to infinite Next notifications may be delivered. If either
					an Error or Complete notification is delivered, then nothing else can be delivered afterwards.
				</blockquote>
				<aside class="notes">
					<ul>
						<li>Observables strictly adhere to the Observable Contract</li>
						<li>It is a good idea to wrap any code in subscribe with try/catch block that will deliver an
							Error notification if it catches an exception:</li>
					</ul>
				</aside>
			</section>
			<!-- Slide 13-->
			<section>
				<h3>Disposing Observable Executions</h3>
				When an observable is subscribed it occupies some resources, it is neccessary to release those resorces
				when it's work is done.
				<pre><code class="hljs">
import { from } from 'rxjs';

const observable = from([10, 20, 30]);
const subscription = observable.subscribe(x => console.log(x));
// Later:
subscription.unsubscribe();
	</code></pre>
				<small>It can also be used to cancel an ongoing task such as API calls</small>
				<blockquote>When you subscribe, you get back a Subscription, which represents the ongoing execution.
					Just call unsubscribe() to cancel the execution.</blockquote>
			</section>
			<section>
				<iframe src="marble/index.html#race"></iframe>
			</section>
		</div>
	</div>

	<script src="js/reveal.js"></script>

	<script>
		Reveal.initialize({
			dependencies: [
				{ src: 'plugin/notes/notes.js', async: true },
				{ src: 'plugin/highlight/highlight.js', async: true }
			]
		});
	</script>
</body>

</html>